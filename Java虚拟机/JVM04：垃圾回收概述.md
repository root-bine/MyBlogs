## 1、<span style="color:brown">判断对象回收：</span>

**1.1、引用计数法：**

> Python的虚拟机就采用的引用计数法进行垃圾回收

如果一个对象被其他变量引用<u>一次/两次/n次</u>，就<u>count+1/count+2/count+n</u>，而当某个对象不在引用这个对象时，就count-1。直到这个对象的计数变为0时，就将这个对象进行回收。

---

对于循环引用：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="image-20221130183022913" style="zoom:67%;" />

此时A引用B，count_B = count_B + 1，然后B又引用A，count_A = count_A + 1，而没有其他变量引用A、B。

但A、B依旧无法进行垃圾回收，因为此时A、B的计数都为1.

**1.2、可达性分析算法：**

> GC Roots Tracing，又称：可达性分析算法
>
> Java虚拟机中的垃圾回收器采用<u>*可达性分析*</u>来探索**所有存活的对象**

扫描堆中的对象，看是否能够<u>*沿着一系列被称为GC Roots的对象为起点的引用链（Reference Chain）*向下查找</u>该对象：

- 存在，该对象保留；
- 不存在，该对象回收；

---

在Java语言中，可以作为GC Root的对象包含下面几种：

| 类型                                      | 范例                                                         |
| :---------------------------------------- | :----------------------------------------------------------- |
| 虚拟机栈中，<u>局部变量表引用的对象</u>   | 各个线程被调用的方法中使用到的参数、局部变量等               |
| 方法区中，<u>类静态属性引用的对象</u>     | Java类的引用类型静态变量                                     |
| 方法区中，<u>常量引用的对象</u>           | 字符串常量池（string Table） 里的引用                        |
| 本地方法栈中，<u>Native方法引用的对象</u> | \                                                            |
| 所有被同步锁synchronized持有的对象        | \                                                            |
| Java虚拟机内部的引用                      | 基本数据类型对应的Class对象、<br>一些常驻的异常对象（如：NullPointerException、OutOfMemoryError）、<br>系统类加载器 |

**1.3、引用：**

| 引用名称                               | 定义                                                         | 分析                                                         |
| :------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 强引用                                 | 在程序代码之中普遍存在的                                     | 类似“Object obj = new Object0”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象 |
| 软引用                                 | 用来描述一些<u>还有用但并非必需</u>的对象                    | 对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。***在JDK1.2之后，提供了SofReference类来实现软引用***。 |
| 弱引用                                 | 用来描述<u>非必需对象，但它的强度比软引用更弱一些</u>。      | *被弱引用关联的对象只能生存到下一次垃圾收集发生之前*。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<u>***在JDK1.2之后，提供了WeakRefenence类来实现弱引用***</u>。 |
| 虚引用，也称为*幽灵引用*或者*幻影引用* | 它是最弱的一种引用关系。一个对象是否有虚引用的存在,完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 | 为一个对象设置虚引用关联的唯一目的就是<u>*能在这个对象被收集器回收时收到一个系统通知*</u>。<u>**在JDK12之后,提供了PhantomReference类来实现虚引用**</u>。 |

**1.4、回收对象的过程：**

在可达性分析算法中不可达的对象，不一定会被垃圾回收。因此，一个对象的死亡经历两个阶段：

- 对象在进行可达性分析后，发现没有与GC Roots相连接的引用链，会被第一次标记且进行一次筛选；
  - <u>筛选条件：此对象是否有必要执行finalize()方法</u>
  - JVM默认不执行情况：***对象没有覆盖finalize()方法、finalize()方法已经被虚拟机调用过***
- 如果对象被判定为执行finalize()方法，就会被放在F-Queue的队列中，并稍后**由一个JVM自动创建、低优先级的Finalize线程**执行；
  - 此时GC会对F-Queue的队列中对象，进行第二次小规模标记
  - 如果希望对象不被回收，***只需要重新与引用链上的任何一个对象建立连接***即可

---

执行finalize()方法，是指：<u>***JVM触发着方法***，并不需要等待这个方法运行结束</u>。原因在于：如果对象在finalize()方法中<u>执行缓慢/发生了死循环</u>，这就导致在**F-Queue队列中的其他对象永久等待**，以至于导致整个垃圾回收系统崩溃！！！



## 2、<span style="color:brown">垃圾回收算法：</span>

**2.1、垃圾回收机制：**

> 在java中，程序员是不需要显示的去释放一个对象的内存的，而是由JVM自行执行

在JVM中，有一个<u>*低优先级的*</u>垃圾回收线程：Finalize线程，<u>在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行</u>，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

**2.2、标记 — 清除算法：**

> **速度块，但会有大量不连续的内存碎片**

通过*可达性分析算法*<u>标记出需要回收的对象</u>，在完成标记后<u>统一回收有标记的对象</u>。

**Mark-Sweep算法是最基础的收集算法**，后续改进算法皆是以此为基础，存在两方面问题：

- 效率问题：标记和清除两个过程的效率都不高；
- 空间问题：标记清除之后会产生大量不连续的内存碎片；

产生的内存碎片，可能会导致<u>后续程序运行过程中**需要分配较大的对象**</u>时，***无法找到足够的连续内存***，从而触发另一次垃圾回收。

**2.3、复制算法：**

> Coping算法主要是<u>针对于Mark-Sweep算法的效率问题</u>而产生的
>
> **没有内存碎片，但会占用双倍的内存空间**

Coping算法的操作为：

- 将<u>可用内存按容量划分成大小相等的两块</u>，**每次只是用其中的一块**；
- 当这一块内存用完时，就将还存活的对象复制到另一块上，然后再把已使用的内存空间一次清除掉；

采用将内存取半操作，目的在于：

```scss
1. 每次都是'对整个半区进行内存回收', 并且'在内存分配时, 也不需要考虑内存碎片问题';
2. 只需要移动堆顶指针, 按顺序分配内存即可, 使回收过程'实现简单、运行高效';
```

**2.4、标记 — 整理算法：**

> **速度慢，且没有内存碎片**

在**对象存货率较高**时采用Coping算法，回收效率会变低。原因在于：

```scss
如果不想浪费50%的空间, 就'需要额外的空间进行分配担保', 以应对被使用的内存中出现所有对象100%存活的情况
```

---

因此<u>*老年代一般不采用Coping算法，而是采用**Mark-Compact算法***</u>，操作为：

- 采用可达性分析算法，标记处需要回收的对象；
- 标记完成后，<u>让存活的对象都向一边移动</u>，然后**直接清理掉**端边界**以外的内存**；



## 3、<span style="color:brown">分代垃圾回收：</span>

**3.1、堆内存分布：**

> JDK1.7及其以后取消了永久代，采用了Metaspace(元空间)

![image-20221201155015417](https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Heap-Generation_Collection.png)

**3.2、回收算法使用：**

> 当Eden的内存不足时，会触发垃圾回收，称为：Minor GC

一般情况下，**新创建的对象都会被分配到Eden区**。如果经过第一次Minor GC后，仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当<u>它的年龄达到阈值时，就会被移动到年老代中</u>。

| 区域名称 | 分析                                                         | 算法                                 |
| :------- | :----------------------------------------------------------- | :----------------------------------- |
| 新生代   | 每次垃圾回收都会有很多对象死去，仅少数存活，<br>因此<u>只需要付出少量存活对象的复制成本</u>即可完成回收操作 | Coping算法                           |
| 老年代   | 由于**对象存活率高**，且<u>没有额外的空间对它进行分配担保</u> | Mark-Sweep算法  或者Mark-Compact算法 |

**3.3、年轻代中的GC：**

<span style="color:red">在GC开始之前，对象只会存在于**Eden区**和*Survivor区之**from区***，*Survivor区之**to区***是<u>*空的*</u></span>。

在进行GC时，<u>Eden区中所有存活的对象都会被复制到to区</u>。而在from区中，仍存活的对象会根据他们的年龄值来决定去向：

- 达到**年龄阈值**的对象会被移动到年老代中；
- 没有达到阈值的对象会被复制到“to”区域；

经过这次GC后，**Eden区和from区已经被清空**。而“from”和“to”会交换他们的角色：

```scss
新的to就是上次GC前的from, 新的from就是上次GC前的to, '可以保证名为To的Survivor区域是空的'
```

之后，Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

**3.4、GC相关参数：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/GC-Params.png" alt="image-20221201162802169" style="zoom:80%;" />



## 4、<span style="color:brown">垃圾回收器：</span>

**4.1、特点：**

> Stop The World，暂停时间，简称：STW

|          名称           | 线程数 |          应用场景          |                区别                |
| :---------------------: | :----: | :------------------------: | :--------------------------------: |
|      Serial收集器       | 单线程 | Heap内存较小，适合个人使用 |                 /                  |
| Parallel Scavenge收集器 | 多线程 |   Heap内存较大，多核CPU    | 让<u>单位时间内</u>，STW的时间最短 |
|        CMS收集器        | 多线程 |   Heap内存较大，多核CPU    |  尽可能让<u>单次STW的时间</u>最短  |

**4.2、串行收集器：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image-20221201171053937" style="zoom: 67%;" />

开启串行收集器，设置：`-XX:+UseSerialGC= Serial + Serialold`：

- Serial：工作在新生代，采用Coping算法；
- Serialold：工作在老年代，采用Mark-Compact算法；

---

<u>*Serial Old收集器是Serial收集器的**老年代**版本*</u>，是一个单线程收集器，采用：Mark-Compact垃圾回收算法。

这个收集器主要意义是：

- 给Client模式下的虚拟机使用；

- 若<span style="color:green">Serial Old收集器在Server模式下</span>，用途为：
  1. 在JDK1.5及其以前的版本中，与Parallel Scavenge收集器搭配使用；
  2. <span style="color:red"><u>作为CMS收集器的后备方案</u>，在**并发收集**发生Concurrent Mode Failure时使用</span>；

**4.3、吞吐量优先收集器：**

> Parallel Old收集器是Parallel Scavenge收集器的**老年代**版本，是多线程收集器，采用：Mark-Compact垃圾回收算法

![image-20221201211758835](https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Parallel%20Scavenge%E6%94%B6%E9%9B%86%E5%99%A8.png)

在JDK1.8中，<u>新生代GC回收器`-XX:+UseParallelGC`</u>和<u>老年代GC回收器：`-XX :+UseParalle10ldGC`</u>均默认开启，分别采用的垃圾回收算法为：Coping算法、Mark-Compact算法。

| 参数名称                   | 设定值                                 | 功能                     |
| :------------------------- | -------------------------------------- | ------------------------ |
| -XX :MaxGCPauseMillis=ms   | 默认为200ms，参数允许值为大于0的毫秒值 | 控制最大垃圾收集停顿时间 |
| -XX:GCTimeRatio=ratio      | 默认值为99，范围(0,100)                | 设置吞吐量的大小         |
| -XX:+UseAdaptiveSizePolicy | /                                      | GC自适应调节策略开关     |
| -XX:ParallelGCThreads=n    | 数值范围大于0                          | 限制垃圾收集的线程数量   |

---

使用`-XX :MaxGCPauseMillis`时，<u>收集器尽可能保证内存回收花费的时间不超过设定值</u>。而**并不是该设定值越小，垃圾回收速度就越快**，<span style="color:red">GC停顿时间缩短是以牺牲<u>吞吐量和新生代空间</u>来换取的</span>！！！

使用`-XX:GCTimeRatio`，设定值默认99，即：允许最大<u>1/(1+99))*100%=**1%**</u>的垃圾收集时间。

---

开启`-XX:+UseAdaptiveSizePolicyGC`，可以省去手动指定一些参数（此处部分列举)：

- 新生代的大小：-Xmm
- Eden与Survivor的比例：-XX:SurvivorRatio
- 晋升老年代对象大小：-XX:PretenureThreshold

针对于上述参数，开启这个相当于使用了**自适应调节的策略**：<span style="color:red">虚拟机会根据'当前系统的运行情况'收集'性能监控信息', 动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</span>。

**4.4、并发低停顿收集器：**

![image-20221202152112845](https://raw.githubusercontent.com/root-bine/image/main/Typora-image/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png)

CMS收集器 是 基于<u>**Mark-Sweep算法进行垃圾回收**</u>，主要<u>*应用在老年代*</u>中，步骤为：

- 初始标记（需要`Stop The World`）

  ```scss
  初始标记仅仅只是'标记一下GC Roots能直接关联到的对象', 速度很快
  ```

- 并发标记

  ```scss
  并发标记是'进行GC Roots Tracing（可达性分析算法）'的过程
  ```

- 重新标记（需要`Stop The World`）

  ```scss
  重新标记是'修正并发标记期间因用户程序继续运行', 导致'标记发生变动的部分对象'的记录
  ```

- 并发清除

<span style="color:red">重新标记的停顿时间，比初始标记长一些，但远比并发标记的时间短</span>。在整个过程中，<u>耗时最长的并发标记和并发清除过程收集器线程</u>都可以与用户线程一起工作。因此，<span style="color:green">CMS收集器的内存回收过程都与用户线程一起**并发执行**</span>！！！

---

Concurrent Mark Sweep收集器时一种以<u>**获取最短回收停顿时间**</u>为目标的收集器，又称：`Concurrent Low Pause Collector`。

| 参数名称                             | 功能                                                       | 说明                                                         |
| ------------------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| -XX:CMSInitiatingOccupancyFraction=n | 设置CMS在老年代中的触发阙值                                | <u>阙值设置太高</u>会导致大量**CMF失败**，性能下降           |
| -XX:CMSCompactAtFullCollection       | 在CMS要进行FullGC时，开启内存碎片的合并整理过程            | 默认就是开启的，由于<u>内存整理过程是无法并发的</u>，空间碎片问题虽然解决，但STW延长 |
| -XX:CMSFullGCsBeforeCompaction=n     | 设置执行n次不压缩FullGC后，<u>跟着来一次带压缩</u>的FullGC | 默认值为0, 即: 每一次进入FullGC时进行碎片整理                |
| -XX:ParallelGCThreads=n              | 限制垃圾收集的线程数量                                     | 数值范围大于0                                                |

CMS收集器具备<span style="color:blue">**<u>*并发收集、低停顿*</u>**</span>的优点，但也有三个明显的缺点：

- CMS对CPU资源非常敏感；

  ```scss
  1. 在并发阶段, CMS'不会导致用户线程停顿', 但'会占用一部分CPU资源, 使得应用程序变慢, 总吞吐量降低';
  2. CMS默认启动线程数: (CUP核数+3)/4, 即: 当CPU核数>4时, CMS垃圾回收线程不少于25%的CPU资源;
  ```

- CMS<u>无法处理浮动垃圾（Floating Garbage）</u>，可能出现**Concurrent Mode Failure失败**而导致另一次Full GC的产生；

  [^Floating Garbage]: 在<u>CMS并发清除阶段</u>，**用户线程依旧在运行**，从而会产生许多<u>*出现在标记过程之后的新垃圾*</u>。而CMS无法在当次收集中处理它们，只能等待下一次GC再处理。

  ```scss
  JDK1.5的默认设置下, CMS当'老年代使用了68%的空间'就会被激活。JDK1.6中, CMS的'启动阙值'已经'提升至92%'
  ---------------------------------------------------------------------------------------------------------
  要是CMS运行期间'预留的空间无法满足程序的需求', 就会出现一次'Concurrent Mode Failure失败', 就会开启预备方案:
  		# 临时启用Serial Old收集器来重新进行老年代的垃圾收集, 但STW较长
  ```

- CMS基于**标记—清除算法**回收垃圾，会产生许多内存碎片，导致<u>后续程序运行过程中**需要分配较大的对象**</u>时，***无法找到足够的连续内存***，从而触发另一次**垃圾回收（Full GC）**；
